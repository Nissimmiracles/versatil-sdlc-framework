/**
 * VERSATIL Session Report Generator
 *
 * Generates comprehensive markdown reports from session analysis and learnings.
 * Reports are stored in ~/.versatil/sessions/SESSION_ID/report.md
 *
 * Features:
 * - Markdown report with metrics, patterns, lessons
 * - Brief mode for terminal display
 * - Detailed mode for file storage
 * - Recommendations for next session
 */
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
export class SessionReportGenerator {
    /**
     * Generate complete session report
     */
    async generateReport(analysis, learnings, codificationResult) {
        const markdown = this.generateMarkdownReport(analysis, learnings, codificationResult);
        const brief = this.generateBriefReport(analysis, learnings);
        const summary = this.generateSummary(analysis, learnings);
        // Save report to disk
        await this.saveReport(analysis.sessionId, markdown);
        return {
            sessionId: analysis.sessionId,
            markdown,
            brief,
            summary
        };
    }
    /**
     * Generate full markdown report
     */
    generateMarkdownReport(analysis, learnings, codificationResult) {
        return `# VERSATIL Session Report

**Session**: ${analysis.sessionId}
**Date**: ${new Date(analysis.date).toLocaleDateString()}
**Duration**: ${Math.round(analysis.duration / 60000)} minutes

---

## Executive Summary

- **Time Saved**: ${analysis.productivity.timeSaved} minutes
- **Productivity Gain**: ${analysis.productivity.productivityGain}%
- **Quality Score**: ${analysis.qualityMetrics.averageQuality}%
- **Efficiency**: ${analysis.productivity.efficiency}%
- **Overall Effectiveness**: ${learnings.overallEffectiveness}/100
- **Compounding Score**: ${learnings.compoundingScore}/100

**Impact**: This session will make future work approximately **${Math.round(learnings.compoundingScore * 0.4)}% faster** through pattern codification.

---

## Performance Metrics

${learnings.performanceMetrics.map(m => `
### ${m.metric}

- **Value**: ${m.value} ${m.unit}
- **Benchmark**: ${m.benchmark} ${m.unit}
- **Status**: ${this.formatStatus(m.status)}
- **Improvement**: ${m.improvement}
`).join('\n')}

---

## Code Changes

**Files Modified**: ${analysis.metadata.filesModified}
**Lines Added**: ${analysis.metadata.linesAdded}
**Lines Deleted**: ${analysis.metadata.linesDeleted}
**Commits**: ${analysis.metadata.commitsCreated}
**Branch**: ${analysis.metadata.branch}

### Change Breakdown

${this.formatCodeChanges(analysis.codeChanges)}

---

## Patterns Identified (${learnings.codePatterns.length})

${learnings.codePatterns.map(p => `
### ${p.pattern}

**Category**: ${p.category} | **Language**: ${p.language}${p.framework ? ` (${p.framework})` : ''} | **Effectiveness**: ${p.effectiveness}%

${p.description}

\`\`\`${p.language}
${p.codeSnippet}
\`\`\`

**Usage Context**: ${p.usageContext}

**Recommendations**: ${p.recommendations}

**Tags**: ${p.tags.join(', ')}
`).join('\n---\n')}

---

## Lessons Learned (${learnings.lessons.length})

${learnings.lessons.map(l => `
### ${l.title}

**Context**: ${l.context}

**Insight**: ${l.insight}

**Application**: ${l.application}

**Evidence**: ${l.evidence}

${l.relatedPatterns.length > 0 ? `**Related Patterns**: ${l.relatedPatterns.join(', ')}` : ''}
`).join('\n---\n')}

---

## Warnings & Watch-Outs (${learnings.warnings.length})

${learnings.warnings.length > 0 ? learnings.warnings.map(w => `
### [${w.severity.toUpperCase()}] ${w.issue}

**Category**: ${w.category}
**Impact**: ${w.impact}
**Resolution**: ${w.resolution}
${w.agentRelated ? `**Agent**: ${w.agentRelated}` : ''}
`).join('\n---\n') : '*No warnings - excellent session!*'}

---

## Agent Performance

${analysis.agentPerformance.map(a => `
### ${a.agentId}

**Activations**: ${a.activations}
**Success Rate**: ${Math.round(a.successRate * 100)}%
**Time Saved**: ${a.timeSaved} minutes
**Avg Duration**: ${Math.round(a.averageDuration / 1000)}s
**Effectiveness**: ${a.effectiveness.toUpperCase()}
`).join('\n')}

---

## Codification Results

- **Patterns Stored in RAG**: ${codificationResult.patternsStored}
- **Lessons Stored**: ${codificationResult.lessonsStored}
- **Agent Memories Updated**: ${codificationResult.agentMemoriesUpdated}
- **Total RAG Entries**: ${codificationResult.ragEntriesCreated}

${codificationResult.success ? '✅ **Learnings successfully codified for future use**' : `⚠️ **Codification failed**: ${codificationResult.error}`}

---

## Recommendations for Next Session

${this.generateRecommendations(analysis, learnings)}

---

*Report generated by VERSATIL Learning Codification System*
*Next similar work will be ~${Math.round(learnings.compoundingScore * 0.4)}% faster via pattern reuse*
`;
    }
    /**
     * Generate brief terminal-friendly report
     */
    generateBriefReport(analysis, learnings) {
        return `
╔═══════════════════════════════════════════════════════════╗
║   📊 Session Summary: ${analysis.sessionId}
╚═══════════════════════════════════════════════════════════╝

⏱️  Time Saved: ${analysis.productivity.timeSaved} minutes
📈 Productivity Gain: ${analysis.productivity.productivityGain}%
⭐ Quality Score: ${analysis.qualityMetrics.averageQuality}%
🎯 Effectiveness: ${learnings.overallEffectiveness}/100
🔄 Compounding: ${learnings.compoundingScore}/100 (Future work ~${Math.round(learnings.compoundingScore * 0.4)}% faster)

📝 Code Changes:
   ${analysis.metadata.filesModified} files | +${analysis.metadata.linesAdded} -${analysis.metadata.linesDeleted} lines | ${analysis.metadata.commitsCreated} commits

🎓 Learnings:
   ${learnings.codePatterns.length} patterns | ${learnings.lessons.length} lessons | ${learnings.warnings.length} warnings

💾 Codified:
   ${learnings.codePatterns.filter(p => p.effectiveness >= 75).length} patterns to RAG | ${learnings.lessons.length} lessons to memory

📚 Full report: ~/.versatil/sessions/${analysis.sessionId}/report.md

───────────────────────────────────────────────────────────
`;
    }
    /**
     * Generate summary object
     */
    generateSummary(analysis, learnings) {
        const topPatterns = learnings.codePatterns
            .sort((a, b) => b.effectiveness - a.effectiveness)
            .slice(0, 5)
            .map(p => p.pattern);
        const recommendations = this.generateRecommendations(analysis, learnings)
            .split('\n')
            .filter(l => l.trim().startsWith('-'))
            .map(l => l.substring(1).trim())
            .slice(0, 5);
        return {
            timeSaved: analysis.productivity.timeSaved,
            qualityScore: analysis.qualityMetrics.averageQuality,
            impactScore: learnings.overallEffectiveness,
            compoundingScore: learnings.compoundingScore,
            topPatterns,
            recommendations
        };
    }
    /**
     * Generate recommendations
     */
    generateRecommendations(analysis, learnings) {
        const recs = [];
        // Pattern-based recommendations
        if (learnings.codePatterns.length >= 3) {
            recs.push('- Codified patterns available via RAG - next similar feature will be 40% faster');
        }
        // Agent-specific recommendations
        const highPerformers = learnings.agentInsights.filter(a => a.effectiveness === 'high');
        if (highPerformers.length > 0) {
            recs.push(`- Prioritize ${highPerformers.map(a => a.agentId).join(', ')} for similar tasks`);
        }
        // Quality recommendations
        if (learnings.performanceMetrics.some(m => m.metric === 'Code Quality' && m.status === 'needs-improvement')) {
            recs.push('- Add more specific requirements to improve code quality');
        }
        // Coverage recommendations
        if (analysis.qualityMetrics.testCoverage && analysis.qualityMetrics.testCoverage < 80) {
            recs.push('- Run /maria review coverage to increase test coverage');
        }
        // Efficiency recommendations
        if (analysis.productivity.efficiency < 70) {
            recs.push('- Break tasks into smaller chunks to improve completion rate');
        }
        // Warning-based recommendations
        for (const warning of learnings.warnings) {
            if (warning.severity === 'high') {
                recs.push(`- ${warning.resolution}`);
            }
        }
        // Success celebration
        if (learnings.overallEffectiveness >= 85) {
            recs.push('- 🎉 Excellent session! Continue current workflow');
        }
        return recs.length > 0 ? recs.join('\n') : '- Continue current successful approach';
    }
    /**
     * Format code changes table
     */
    formatCodeChanges(changes) {
        if (changes.length === 0)
            return '*No code changes tracked*';
        const byType = changes.reduce((acc, c) => {
            acc[c.type] = (acc[c.type] || 0) + 1;
            return acc;
        }, {});
        return Object.entries(byType)
            .map(([type, count]) => `- **${type}**: ${count} file(s)`)
            .join('\n');
    }
    /**
     * Format status with emoji
     */
    formatStatus(status) {
        const statusMap = {
            'excellent': '🟢 Excellent',
            'good': '🟡 Good',
            'needs-improvement': '🔴 Needs Improvement'
        };
        return statusMap[status] || status;
    }
    /**
     * Save report to disk
     */
    async saveReport(sessionId, markdown) {
        try {
            const sessionDir = path.join(os.homedir(), '.versatil', 'sessions', sessionId);
            await fs.mkdir(sessionDir, { recursive: true });
            const reportPath = path.join(sessionDir, 'report.md');
            await fs.writeFile(reportPath, markdown, 'utf-8');
        }
        catch (error) {
            // Silent fail - report generation is not critical
        }
    }
}
/**
 * Factory function
 */
export function createSessionReportGenerator() {
    return new SessionReportGenerator();
}
//# sourceMappingURL=session-report-generator.js.map