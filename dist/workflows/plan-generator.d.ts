/**
 * @fileoverview Plan Generator - Creates structured multi-phase plans with historical context
 *
 * Generates comprehensive execution plans using:
 * - Phase breakdown (requirements, development, integration, QA)
 * - Agent assignments per phase
 * - Time estimates from historical RAG data
 * - Dependencies and parallel execution opportunities
 *
 * @module workflows/plan-generator
 * @version 6.5.0
 */
import { EnhancedVectorMemoryStore } from '../rag/enhanced-vector-memory-store.js';
import { PlanModeDetection } from './plan-mode-detector.js';
/**
 * Generated execution plan
 */
export interface ExecutionPlan {
    /** Plan metadata */
    metadata: PlanMetadata;
    /** Execution phases */
    phases: PlanPhase[];
    /** Overall estimates */
    estimates: PlanEstimates;
    /** Dependencies between phases */
    dependencies: PhaseDependency[];
    /** Parallel execution opportunities */
    parallelGroups: PhaseGroup[];
    /** Risk assessment */
    risks: RiskAssessment;
    /** Historical context used */
    historicalContext: HistoricalContext[];
}
/**
 * Plan metadata
 */
export interface PlanMetadata {
    /** Unique plan ID */
    id: string;
    /** Creation timestamp */
    createdAt: Date;
    /** Plan version */
    version: string;
    /** Feature/task description */
    description: string;
    /** Complexity assessment */
    complexity: 'low' | 'medium' | 'high';
    /** Generated by */
    generatedBy: string;
}
/**
 * Plan phase
 */
export interface PlanPhase {
    /** Phase ID */
    id: string;
    /** Phase name */
    name: string;
    /** Phase description */
    description: string;
    /** Assigned agents */
    agents: string[];
    /** Phase tasks */
    tasks: PhaseTask[];
    /** Estimated duration in minutes */
    estimatedDuration: number;
    /** Phase dependencies (IDs of phases that must complete first) */
    dependsOn: string[];
    /** Can this phase run in parallel with others */
    canParallelize: boolean;
    /** Quality gates for this phase */
    qualityGates: QualityGate[];
    /** Expected outputs */
    outputs: PhaseOutput[];
}
/**
 * Phase task
 */
export interface PhaseTask {
    /** Task ID */
    id: string;
    /** Task description */
    description: string;
    /** Assigned agent */
    agent: string;
    /** Estimated duration in minutes */
    estimatedDuration: number;
    /** Task inputs */
    inputs: Record<string, any>;
    /** Expected outputs */
    expectedOutputs: Record<string, any>;
    /** Success criteria */
    successCriteria: string[];
    /** Task priority */
    priority: 'low' | 'medium' | 'high';
}
/**
 * Plan estimates
 */
export interface PlanEstimates {
    /** Total estimated duration in minutes (if sequential) */
    totalSequential: number;
    /** Total estimated duration in minutes (with parallelization) */
    totalParallel: number;
    /** Time saved by parallelization */
    timeSaved: number;
    /** Confidence in estimates (0-100%) */
    confidence: number;
    /** Breakdown by phase */
    byPhase: Record<string, number>;
    /** Breakdown by agent */
    byAgent: Record<string, number>;
}
/**
 * Phase dependency
 */
export interface PhaseDependency {
    /** Phase that depends */
    fromPhase: string;
    /** Phase being depended upon */
    toPhase: string;
    /** Type of dependency */
    type: 'hard' | 'soft';
    /** Reason for dependency */
    reason: string;
}
/**
 * Phase group (for parallel execution)
 */
export interface PhaseGroup {
    /** Group ID */
    id: string;
    /** Phases that can run in parallel */
    phases: string[];
    /** Group description */
    description: string;
    /** Estimated duration (max of all phases in group) */
    estimatedDuration: number;
}
/**
 * Quality gate
 */
export interface QualityGate {
    /** Gate type */
    type: 'automated' | 'manual' | 'approval';
    /** Gate description */
    description: string;
    /** Criteria to pass */
    criteria: string[];
    /** Is this gate mandatory */
    mandatory: boolean;
}
/**
 * Phase output
 */
export interface PhaseOutput {
    /** Output type */
    type: 'file' | 'artifact' | 'data' | 'approval';
    /** Output description */
    description: string;
    /** Expected location/format */
    format: string;
    /** Is this output required */
    required: boolean;
}
/**
 * Risk assessment
 */
export interface RiskAssessment {
    /** Overall risk level */
    level: 'low' | 'medium' | 'high';
    /** Identified risks */
    risks: Risk[];
    /** Mitigation strategies */
    mitigations: Mitigation[];
}
/**
 * Individual risk
 */
export interface Risk {
    /** Risk ID */
    id: string;
    /** Risk description */
    description: string;
    /** Risk level */
    level: 'low' | 'medium' | 'high';
    /** Affected phases */
    affectedPhases: string[];
    /** Probability (0-100%) */
    probability: number;
    /** Impact (0-100%) */
    impact: number;
}
/**
 * Mitigation strategy
 */
export interface Mitigation {
    /** Mitigation for risk ID */
    forRisk: string;
    /** Mitigation strategy */
    strategy: string;
    /** Implementation phase */
    implementIn: string;
    /** Effectiveness (0-100%) */
    effectiveness: number;
}
/**
 * Historical context from RAG
 */
export interface HistoricalContext {
    /** Context type */
    type: 'similar-feature' | 'agent-performance' | 'time-estimate' | 'pattern';
    /** Description */
    description: string;
    /** Relevance score (0-1) */
    relevance: number;
    /** Data */
    data: any;
    /** Source */
    source: string;
}
export declare class PlanGenerator {
    private logger;
    private vectorStore?;
    constructor(vectorStore?: EnhancedVectorMemoryStore);
    /**
     * Generate execution plan from detection result and context
     */
    generatePlan(detection: PlanModeDetection, request: string, projectContext?: any): Promise<ExecutionPlan>;
    /**
     * Retrieve relevant historical context from RAG
     */
    private retrieveHistoricalContext;
    /**
     * Create plan metadata
     */
    private createMetadata;
    /**
     * Generate execution phases
     */
    private generatePhases;
    /**
     * Create Requirements Analysis phase
     */
    private createRequirementsPhase;
    /**
     * Create Database Layer phase
     */
    private createDatabasePhase;
    /**
     * Create Backend API phase
     */
    private createBackendPhase;
    /**
     * Create Frontend UI phase
     */
    private createFrontendPhase;
    /**
     * Create Integration phase (for three-tier architecture)
     */
    private createIntegrationPhase;
    /**
     * Create Quality Assurance phase
     */
    private createQualityPhase;
    /**
     * Get historical duration for an agent from context
     */
    private getHistoricalDuration;
    /**
     * Calculate overall estimates
     */
    private calculateEstimates;
    /**
     * Identify dependencies between phases
     */
    private identifyDependencies;
    /**
     * Find parallel execution opportunities
     */
    private findParallelGroups;
    /**
     * Assess risks for the plan
     */
    private assessRisks;
}
export default PlanGenerator;
