512947f34f8cb416006fcd9964e33e16
"use strict";
/**
 * VERSATIL Framework - Agent Pool
 * Implements agent warm-up pooling for 50% faster activation
 *
 * Features:
 * - Pre-loads 3 instances of each agent type
 * - O(1) agent retrieval from pool
 * - Automatic pool replenishment
 * - Adaptive pool sizing based on usage patterns
 * - Pool statistics tracking (hit rate, allocation time)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.globalAgentPool = exports.AgentPool = void 0;
const enhanced_maria_js_1 = require("./enhanced-maria.js");
const enhanced_james_js_1 = require("./enhanced-james.js");
const enhanced_marcus_js_1 = require("./enhanced-marcus.js");
const sarah_pm_js_1 = require("./sarah-pm.js");
const alex_ba_js_1 = require("./alex-ba.js");
const dr_ai_ml_js_1 = require("./dr-ai-ml.js");
const enhanced_vector_memory_store_js_1 = require("../rag/enhanced-vector-memory-store.js");
const events_1 = require("events");
class AgentPool extends events_1.EventEmitter {
    constructor(config = {}) {
        super();
        this.warmAgents = new Map();
        this.allocationTimes = [];
        this.config = {
            poolSize: 3,
            enableAdaptive: true,
            warmUpOnInit: true,
            minPoolSize: 1,
            maxPoolSize: 10,
            ...config
        };
        this.vectorStore = new enhanced_vector_memory_store_js_1.EnhancedVectorMemoryStore();
        this.statistics = {
            totalRequests: 0,
            poolHits: 0,
            poolMisses: 0,
            hitRate: 0,
            averageAllocationTime: 0,
            currentPoolSizes: new Map()
        };
        // Initialize pool for all agent types
        const agentTypes = ['maria-qa', 'james-frontend', 'marcus-backend', 'sarah-pm', 'alex-ba', 'dr-ai-ml'];
        for (const type of agentTypes) {
            this.warmAgents.set(type, []);
        }
    }
    /**
     * Initialize agent pool with warm instances
     *
     * LAZY INITIALIZATION:
     * - Does NOT pre-create agents (avoids hanging on agent constructors)
     * - Just marks pool as ready
     * - Agents will be created on-demand on first getAgent() call
     * - Background warming happens asynchronously after first allocation
     */
    async initialize() {
        if (!this.config.warmUpOnInit) {
            console.log('ðŸ”¥ Agent pool initialized (lazy mode - warming disabled)');
            return;
        }
        console.log('ðŸ”¥ Agent pool initialized (lazy warm-up mode)');
        console.log('   â„¹ï¸  Agents will warm up on first request (faster daemon startup)');
        const agentTypes = ['maria-qa', 'james-frontend', 'marcus-backend', 'sarah-pm', 'alex-ba', 'dr-ai-ml'];
        // Start background warming (non-blocking)
        this.backgroundWarmUp(agentTypes).catch(err => {
            console.error('âš ï¸  Background warm-up failed (non-critical):', err.message);
            console.log('   â„¹ï¸  Agent pool will fall back to on-demand creation');
        });
        this.emit('pool:initialized', {
            totalInstances: 0, // None pre-created
            agentTypes,
            mode: 'lazy'
        });
    }
    /**
     * Background warm-up (non-blocking, best-effort)
     */
    async backgroundWarmUp(agentTypes) {
        // Wait 2 seconds to let daemon finish startup
        await new Promise(resolve => setTimeout(resolve, 2000));
        console.log('ðŸ”¥ Starting background agent warm-up...');
        for (const agentType of agentTypes) {
            try {
                const agent = await this.createAgent(agentType);
                await this.warmUpAgent(agent);
                const pool = this.warmAgents.get(agentType) || [];
                pool.push(agent);
                this.warmAgents.set(agentType, pool);
                this.statistics.currentPoolSizes.set(agentType, pool.length);
                console.log(`   âœ… ${agentType}: 1 instance warmed up`);
            }
            catch (err) {
                console.warn(`   âš ï¸  Failed to warm up ${agentType}: ${err.message}`);
                // Continue with other agents
            }
        }
        console.log('âœ… Background warm-up complete');
    }
    /**
     * Get agent from pool (with fallback to cold start)
     */
    async getAgent(type) {
        const startTime = Date.now();
        this.statistics.totalRequests++;
        const pool = this.warmAgents.get(type) || [];
        if (pool.length > 0) {
            // Pool hit - return warm agent
            const agent = pool.shift();
            this.statistics.poolHits++;
            // Async replenish pool (don't wait)
            this.replenishPool(type).catch(err => console.error(`Failed to replenish pool for ${type}:`, err));
            const allocTime = Date.now() - startTime;
            this.recordAllocationTime(allocTime);
            this.emit('agent:allocated', {
                type,
                fromPool: true,
                allocationTime: allocTime
            });
            return agent;
        }
        else {
            // Pool miss - cold start
            this.statistics.poolMisses++;
            const agent = await this.createAgent(type);
            await this.warmUpAgent(agent);
            const allocTime = Date.now() - startTime;
            this.recordAllocationTime(allocTime);
            this.emit('agent:allocated', {
                type,
                fromPool: false,
                allocationTime: allocTime
            });
            // Replenish pool after cold start
            this.replenishPool(type).catch(err => console.error(`Failed to replenish pool for ${type}:`, err));
            return agent;
        }
    }
    /**
     * Release agent back to pool
     */
    async releaseAgent(agent) {
        const type = agent.id;
        const pool = this.warmAgents.get(type) || [];
        // Only return to pool if below max size
        if (pool.length < this.config.maxPoolSize) {
            // Clean up agent state before returning to pool
            await this.cleanupAgent(agent);
            pool.push(agent);
            this.warmAgents.set(type, pool);
            this.statistics.currentPoolSizes.set(type, pool.length);
            this.emit('agent:released', {
                type,
                poolSize: pool.length
            });
        }
        else {
            // Pool is full, discard agent
            this.emit('agent:discarded', {
                type,
                reason: 'pool_full'
            });
        }
    }
    /**
     * Create new agent instance (with error handling)
     */
    async createAgent(type) {
        try {
            switch (type) {
                case 'maria-qa':
                    return new enhanced_maria_js_1.EnhancedMaria(this.vectorStore);
                case 'james-frontend':
                    return new enhanced_james_js_1.EnhancedJames(this.vectorStore);
                case 'marcus-backend':
                    return new enhanced_marcus_js_1.EnhancedMarcus(this.vectorStore);
                case 'sarah-pm':
                    return new sarah_pm_js_1.SarahPm(this.vectorStore);
                case 'alex-ba':
                    return new alex_ba_js_1.AlexBa(this.vectorStore);
                case 'dr-ai-ml':
                    return new dr_ai_ml_js_1.DrAiMl(this.vectorStore);
                default:
                    throw new Error(`Unknown agent type: ${type}`);
            }
        }
        catch (error) {
            console.error(`âŒ Failed to create agent ${type}:`, error.message);
            throw error; // Re-throw for caller to handle
        }
    }
    /**
     * Warm up agent (pre-load resources, RAG patterns, etc.)
     */
    async warmUpAgent(agent) {
        // Warm-up activities:
        // 1. Pre-load RAG patterns (if agent uses RAG)
        // 2. Initialize any heavy resources
        // 3. Compile patterns/rules
        // 4. Connect to external services if needed
        // For now, just ensure agent is ready
        // TODO: Add agent-specific warm-up methods in BaseAgent
        await Promise.resolve();
    }
    /**
     * Clean up agent before returning to pool
     */
    async cleanupAgent(agent) {
        // Cleanup activities:
        // 1. Clear temporary state
        // 2. Reset context
        // 3. Close any open connections
        // 4. Clear caches
        await Promise.resolve();
    }
    /**
     * Replenish pool to target size
     */
    async replenishPool(type) {
        const pool = this.warmAgents.get(type) || [];
        const targetSize = this.config.enableAdaptive
            ? this.calculateAdaptiveSize(type)
            : this.config.poolSize;
        while (pool.length < targetSize && pool.length < this.config.maxPoolSize) {
            const agent = await this.createAgent(type);
            await this.warmUpAgent(agent);
            pool.push(agent);
        }
        this.warmAgents.set(type, pool);
        this.statistics.currentPoolSizes.set(type, pool.length);
        this.emit('pool:replenished', {
            type,
            newSize: pool.length
        });
    }
    /**
     * Calculate adaptive pool size based on usage patterns
     */
    calculateAdaptiveSize(type) {
        // Simple adaptive algorithm:
        // - If hit rate > 90%: increase pool size
        // - If hit rate < 50%: decrease pool size
        // - Otherwise: maintain current size
        this.updateHitRate();
        if (this.statistics.hitRate > 0.9) {
            return Math.min(this.config.poolSize + 1, this.config.maxPoolSize);
        }
        else if (this.statistics.hitRate < 0.5) {
            return Math.max(this.config.poolSize - 1, this.config.minPoolSize);
        }
        else {
            return this.config.poolSize;
        }
    }
    /**
     * Record allocation time for statistics
     */
    recordAllocationTime(time) {
        this.allocationTimes.push(time);
        // Keep only last 100 allocations
        if (this.allocationTimes.length > 100) {
            this.allocationTimes.shift();
        }
        // Update average
        const sum = this.allocationTimes.reduce((a, b) => a + b, 0);
        this.statistics.averageAllocationTime = sum / this.allocationTimes.length;
    }
    /**
     * Update hit rate statistic
     */
    updateHitRate() {
        if (this.statistics.totalRequests > 0) {
            this.statistics.hitRate = this.statistics.poolHits / this.statistics.totalRequests;
        }
    }
    /**
     * Get pool statistics
     */
    getStatistics() {
        this.updateHitRate();
        return { ...this.statistics };
    }
    /**
     * Get current pool size for agent type
     */
    getPoolSize(type) {
        const pool = this.warmAgents.get(type) || [];
        return pool.length;
    }
    /**
     * Clear all pools (with proper cleanup to prevent memory leaks)
     */
    async clearAll() {
        // Destroy agents before clearing pools
        for (const [type, pool] of this.warmAgents.entries()) {
            for (const agent of pool) {
                if (typeof agent.destroy === 'function') {
                    agent.destroy();
                }
            }
        }
        this.warmAgents.clear();
        this.statistics = {
            totalRequests: 0,
            poolHits: 0,
            poolMisses: 0,
            hitRate: 0,
            averageAllocationTime: 0,
            currentPoolSizes: new Map()
        };
        this.allocationTimes = [];
        this.emit('pool:cleared');
    }
    /**
     * Get pool statistics
     */
    getStats() {
        const poolSize = {};
        const hits = {};
        const misses = {};
        this.warmAgents.forEach((agents, agentType) => {
            poolSize[agentType] = agents.length;
            hits[agentType] = 0; // Placeholder - would track in real implementation
            misses[agentType] = 0;
        });
        return {
            poolSize,
            hits,
            misses,
            totalHits: this.statistics.poolHits,
            totalMisses: this.statistics.poolMisses,
            hitRate: this.statistics.hitRate
        };
    }
    /**
     * Shutdown agent pool
     */
    async shutdown() {
        await this.clearAll();
        this.emit('pool:shutdown');
    }
}
exports.AgentPool = AgentPool;
// Export singleton instance
exports.globalAgentPool = new AgentPool();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL25pc3NpbW1lbmFzaGUvVkVSU0FUSUwgU0RMQyBGVy9zcmMvYWdlbnRzL2FnZW50LXBvb2wudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7O0dBVUc7OztBQUdILDJEQUFvRDtBQUNwRCwyREFBb0Q7QUFDcEQsNkRBQXNEO0FBQ3RELCtDQUF3QztBQUN4Qyw2Q0FBc0M7QUFDdEMsK0NBQXVDO0FBQ3ZDLDRGQUFtRjtBQUNuRixtQ0FBc0M7QUFtQnRDLE1BQWEsU0FBVSxTQUFRLHFCQUFZO0lBT3pDLFlBQVksU0FBbUMsRUFBRTtRQUMvQyxLQUFLLEVBQUUsQ0FBQztRQVBGLGVBQVUsR0FBNkIsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUlqRCxvQkFBZSxHQUFhLEVBQUUsQ0FBQztRQUtyQyxJQUFJLENBQUMsTUFBTSxHQUFHO1lBQ1osUUFBUSxFQUFFLENBQUM7WUFDWCxjQUFjLEVBQUUsSUFBSTtZQUNwQixZQUFZLEVBQUUsSUFBSTtZQUNsQixXQUFXLEVBQUUsQ0FBQztZQUNkLFdBQVcsRUFBRSxFQUFFO1lBQ2YsR0FBRyxNQUFNO1NBQ1YsQ0FBQztRQUVGLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSwyREFBeUIsRUFBRSxDQUFDO1FBRW5ELElBQUksQ0FBQyxVQUFVLEdBQUc7WUFDaEIsYUFBYSxFQUFFLENBQUM7WUFDaEIsUUFBUSxFQUFFLENBQUM7WUFDWCxVQUFVLEVBQUUsQ0FBQztZQUNiLE9BQU8sRUFBRSxDQUFDO1lBQ1YscUJBQXFCLEVBQUUsQ0FBQztZQUN4QixnQkFBZ0IsRUFBRSxJQUFJLEdBQUcsRUFBRTtTQUM1QixDQUFDO1FBRUYsc0NBQXNDO1FBQ3RDLE1BQU0sVUFBVSxHQUFHLENBQUMsVUFBVSxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDdkcsS0FBSyxNQUFNLElBQUksSUFBSSxVQUFVLEVBQUUsQ0FBQztZQUM5QixJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FB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O0FBQ2YsUUFBQSxlQUFlLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvbmlzc2ltbWVuYXNoZS9WRVJTQVRJTCBTRExDIEZXL3NyYy9hZ2VudHMvYWdlbnQtcG9vbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFZFUlNBVElMIEZyYW1ld29yayAtIEFnZW50IFBvb2xcbiAqIEltcGxlbWVudHMgYWdlbnQgd2FybS11cCBwb29saW5nIGZvciA1MCUgZmFzdGVyIGFjdGl2YXRpb25cbiAqXG4gKiBGZWF0dXJlczpcbiAqIC0gUHJlLWxvYWRzIDMgaW5zdGFuY2VzIG9mIGVhY2ggYWdlbnQgdHlwZVxuICogLSBPKDEpIGFnZW50IHJldHJpZXZhbCBmcm9tIHBvb2xcbiAqIC0gQXV0b21hdGljIHBvb2wgcmVwbGVuaXNobWVudFxuICogLSBBZGFwdGl2ZSBwb29sIHNpemluZyBiYXNlZCBvbiB1c2FnZSBwYXR0ZXJuc1xuICogLSBQb29sIHN0YXRpc3RpY3MgdHJhY2tpbmcgKGhpdCByYXRlLCBhbGxvY2F0aW9uIHRpbWUpXG4gKi9cblxuaW1wb3J0IHsgQmFzZUFnZW50IH0gZnJvbSAnLi9iYXNlLWFnZW50LmpzJztcbmltcG9ydCB7IEVuaGFuY2VkTWFyaWEgfSBmcm9tICcuL2VuaGFuY2VkLW1hcmlhLmpzJztcbmltcG9ydCB7IEVuaGFuY2VkSmFtZXMgfSBmcm9tICcuL2VuaGFuY2VkLWphbWVzLmpzJztcbmltcG9ydCB7IEVuaGFuY2VkTWFyY3VzIH0gZnJvbSAnLi9lbmhhbmNlZC1tYXJjdXMuanMnO1xuaW1wb3J0IHsgU2FyYWhQbSB9IGZyb20gJy4vc2FyYWgtcG0uanMnO1xuaW1wb3J0IHsgQWxleEJhIH0gZnJvbSAnLi9hbGV4LWJhLmpzJztcbmltcG9ydCB7IERyQWlNbCB9IGZyb20gJy4vZHItYWktbWwuanMnO1xuaW1wb3J0IHsgRW5oYW5jZWRWZWN0b3JNZW1vcnlTdG9yZSB9IGZyb20gJy4uL3JhZy9lbmhhbmNlZC12ZWN0b3ItbWVtb3J5LXN0b3JlLmpzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWdlbnRQb29sQ29uZmlnIHtcbiAgcG9vbFNpemU6IG51bWJlcjtcbiAgZW5hYmxlQWRhcHRpdmU6IGJvb2xlYW47XG4gIHdhcm1VcE9uSW5pdDogYm9vbGVhbjtcbiAgbWluUG9vbFNpemU6IG51bWJlcjtcbiAgbWF4UG9vbFNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb29sU3RhdGlzdGljcyB7XG4gIHRvdGFsUmVxdWVzdHM6IG51bWJlcjtcbiAgcG9vbEhpdHM6IG51bWJlcjtcbiAgcG9vbE1pc3NlczogbnVtYmVyO1xuICBoaXRSYXRlOiBudW1iZXI7XG4gIGF2ZXJhZ2VBbGxvY2F0aW9uVGltZTogbnVtYmVyO1xuICBjdXJyZW50UG9vbFNpemVzOiBNYXA8c3RyaW5nLCBudW1iZXI+O1xufVxuXG5leHBvcnQgY2xhc3MgQWdlbnRQb29sIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSB3YXJtQWdlbnRzOiBNYXA8c3RyaW5nLCBCYXNlQWdlbnRbXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgY29uZmlnOiBBZ2VudFBvb2xDb25maWc7XG4gIHByaXZhdGUgdmVjdG9yU3RvcmU6IEVuaGFuY2VkVmVjdG9yTWVtb3J5U3RvcmU7XG4gIHByaXZhdGUgc3RhdGlzdGljczogUG9vbFN0YXRpc3RpY3M7XG4gIHByaXZhdGUgYWxsb2NhdGlvblRpbWVzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxBZ2VudFBvb2xDb25maWc+ID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBwb29sU2l6ZTogMyxcbiAgICAgIGVuYWJsZUFkYXB0aXZlOiB0cnVlLFxuICAgICAgd2FybVVwT25Jbml0OiB0cnVlLFxuICAgICAgbWluUG9vbFNpemU6IDEsXG4gICAgICBtYXhQb29sU2l6ZTogMTAsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuXG4gICAgdGhpcy52ZWN0b3JTdG9yZSA9IG5ldyBFbmhhbmNlZFZlY3Rvck1lbW9yeVN0b3JlKCk7XG5cbiAgICB0aGlzLnN0YXRpc3RpY3MgPSB7XG4gICAgICB0b3RhbFJlcXVlc3RzOiAwLFxuICAgICAgcG9vbEhpdHM6IDAsXG4gICAgICBwb29sTWlzc2VzOiAwLFxuICAgICAgaGl0UmF0ZTogMCxcbiAgICAgIGF2ZXJhZ2VBbGxvY2F0aW9uVGltZTogMCxcbiAgICAgIGN1cnJlbnRQb29sU2l6ZXM6IG5ldyBNYXAoKVxuICAgIH07XG5cbiAgICAvLyBJbml0aWFsaXplIHBvb2wgZm9yIGFsbCBhZ2VudCB0eXBlc1xuICAgIGNvbnN0IGFnZW50VHlwZXMgPSBbJ21hcmlhLXFhJywgJ2phbWVzLWZyb250ZW5kJywgJ21hcmN1cy1iYWNrZW5kJywgJ3NhcmFoLXBtJywgJ2FsZXgtYmEnLCAnZHItYWktbWwnXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgYWdlbnRUeXBlcykge1xuICAgICAgdGhpcy53YXJtQWdlbnRzLnNldCh0eXBlLCBbXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYWdlbnQgcG9vbCB3aXRoIHdhcm0gaW5zdGFuY2VzXG4gICAqXG4gICAqIExBWlkgSU5JVElBTElaQVRJT046XG4gICAqIC0gRG9lcyBOT1QgcHJlLWNyZWF0ZSBhZ2VudHMgKGF2b2lkcyBoYW5naW5nIG9uIGFnZW50IGNvbnN0cnVjdG9ycylcbiAgICogLSBKdXN0IG1hcmtzIHBvb2wgYXMgcmVhZHlcbiAgICogLSBBZ2VudHMgd2lsbCBiZSBjcmVhdGVkIG9uLWRlbWFuZCBvbiBmaXJzdCBnZXRBZ2VudCgpIGNhbGxcbiAgICogLSBCYWNrZ3JvdW5kIHdhcm1pbmcgaGFwcGVucyBhc3luY2hyb25vdXNseSBhZnRlciBmaXJzdCBhbGxvY2F0aW9uXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5jb25maWcud2FybVVwT25Jbml0KSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UpSBBZ2VudCBwb29sIGluaXRpYWxpemVkIChsYXp5IG1vZGUgLSB3YXJtaW5nIGRpc2FibGVkKScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn5SlIEFnZW50IHBvb2wgaW5pdGlhbGl6ZWQgKGxhenkgd2FybS11cCBtb2RlKScpO1xuICAgIGNvbnNvbGUubG9nKCcgICDihLnvuI8gIEFnZW50cyB3aWxsIHdhcm0gdXAgb24gZmlyc3QgcmVxdWVzdCAoZmFzdGVyIGRhZW1vbiBzdGFydHVwKScpO1xuXG4gICAgY29uc3QgYWdlbnRUeXBlcyA9IFsnbWFyaWEtcWEnLCAnamFtZXMtZnJvbnRlbmQnLCAnbWFyY3VzLWJhY2tlbmQnLCAnc2FyYWgtcG0nLCAnYWxleC1iYScsICdkci1haS1tbCddO1xuXG4gICAgLy8gU3RhcnQgYmFja2dyb3VuZCB3YXJtaW5nIChub24tYmxvY2tpbmcpXG4gICAgdGhpcy5iYWNrZ3JvdW5kV2FybVVwKGFnZW50VHlwZXMpLmNhdGNoKGVyciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCfimqDvuI8gIEJhY2tncm91bmQgd2FybS11cCBmYWlsZWQgKG5vbi1jcml0aWNhbCk6JywgZXJyLm1lc3NhZ2UpO1xuICAgICAgY29uc29sZS5sb2coJyAgIOKEue+4jyAgQWdlbnQgcG9vbCB3aWxsIGZhbGwgYmFjayB0byBvbi1kZW1hbmQgY3JlYXRpb24nKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZW1pdCgncG9vbDppbml0aWFsaXplZCcsIHtcbiAgICAgIHRvdGFsSW5zdGFuY2VzOiAwLCAvLyBOb25lIHByZS1jcmVhdGVkXG4gICAgICBhZ2VudFR5cGVzLFxuICAgICAgbW9kZTogJ2xhenknXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQmFja2dyb3VuZCB3YXJtLXVwIChub24tYmxvY2tpbmcsIGJlc3QtZWZmb3J0KVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBiYWNrZ3JvdW5kV2FybVVwKGFnZW50VHlwZXM6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gV2FpdCAyIHNlY29uZHMgdG8gbGV0IGRhZW1vbiBmaW5pc2ggc3RhcnR1cFxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7XG5cbiAgICBjb25zb2xlLmxvZygn8J+UpSBTdGFydGluZyBiYWNrZ3JvdW5kIGFnZW50IHdhcm0tdXAuLi4nKTtcblxuICAgIGZvciAoY29uc3QgYWdlbnRUeXBlIG9mIGFnZW50VHlwZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFnZW50ID0gYXdhaXQgdGhpcy5jcmVhdGVBZ2VudChhZ2VudFR5cGUpO1xuICAgICAgICBhd2FpdCB0aGlzLndhcm1VcEFnZW50KGFnZW50KTtcblxuICAgICAgICBjb25zdCBwb29sID0gdGhpcy53YXJtQWdlbnRzLmdldChhZ2VudFR5cGUpIHx8IFtdO1xuICAgICAgICBwb29sLnB1c2goYWdlbnQpO1xuICAgICAgICB0aGlzLndhcm1BZ2VudHMuc2V0KGFnZW50VHlwZSwgcG9vbCk7XG4gICAgICAgIHRoaXMuc3RhdGlzdGljcy5jdXJyZW50UG9vbFNpemVzLnNldChhZ2VudFR5cGUsIHBvb2wubGVuZ3RoKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgICAg4pyFICR7YWdlbnRUeXBlfTogMSBpbnN0YW5jZSB3YXJtZWQgdXBgKTtcbiAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgICAg4pqg77iPICBGYWlsZWQgdG8gd2FybSB1cCAke2FnZW50VHlwZX06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIgYWdlbnRzXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ+KchSBCYWNrZ3JvdW5kIHdhcm0tdXAgY29tcGxldGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWdlbnQgZnJvbSBwb29sICh3aXRoIGZhbGxiYWNrIHRvIGNvbGQgc3RhcnQpXG4gICAqL1xuICBhc3luYyBnZXRBZ2VudCh0eXBlOiBzdHJpbmcpOiBQcm9taXNlPEJhc2VBZ2VudD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5zdGF0aXN0aWNzLnRvdGFsUmVxdWVzdHMrKztcblxuICAgIGNvbnN0IHBvb2wgPSB0aGlzLndhcm1BZ2VudHMuZ2V0KHR5cGUpIHx8IFtdO1xuXG4gICAgaWYgKHBvb2wubGVuZ3RoID4gMCkge1xuICAgICAgLy8gUG9vbCBoaXQgLSByZXR1cm4gd2FybSBhZ2VudFxuICAgICAgY29uc3QgYWdlbnQgPSBwb29sLnNoaWZ0KCkhO1xuICAgICAgdGhpcy5zdGF0aXN0aWNzLnBvb2xIaXRzKys7XG5cbiAgICAgIC8vIEFzeW5jIHJlcGxlbmlzaCBwb29sIChkb24ndCB3YWl0KVxuICAgICAgdGhpcy5yZXBsZW5pc2hQb29sKHR5cGUpLmNhdGNoKGVyciA9PlxuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcmVwbGVuaXNoIHBvb2wgZm9yICR7dHlwZX06YCwgZXJyKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgYWxsb2NUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIHRoaXMucmVjb3JkQWxsb2NhdGlvblRpbWUoYWxsb2NUaW1lKTtcblxuICAgICAgdGhpcy5lbWl0KCdhZ2VudDphbGxvY2F0ZWQnLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGZyb21Qb29sOiB0cnVlLFxuICAgICAgICBhbGxvY2F0aW9uVGltZTogYWxsb2NUaW1lXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGFnZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQb29sIG1pc3MgLSBjb2xkIHN0YXJ0XG4gICAgICB0aGlzLnN0YXRpc3RpY3MucG9vbE1pc3NlcysrO1xuXG4gICAgICBjb25zdCBhZ2VudCA9IGF3YWl0IHRoaXMuY3JlYXRlQWdlbnQodHlwZSk7XG4gICAgICBhd2FpdCB0aGlzLndhcm1VcEFnZW50KGFnZW50KTtcblxuICAgICAgY29uc3QgYWxsb2NUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIHRoaXMucmVjb3JkQWxsb2NhdGlvblRpbWUoYWxsb2NUaW1lKTtcblxuICAgICAgdGhpcy5lbWl0KCdhZ2VudDphbGxvY2F0ZWQnLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGZyb21Qb29sOiBmYWxzZSxcbiAgICAgICAgYWxsb2NhdGlvblRpbWU6IGFsbG9jVGltZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlcGxlbmlzaCBwb29sIGFmdGVyIGNvbGQgc3RhcnRcbiAgICAgIHRoaXMucmVwbGVuaXNoUG9vbCh0eXBlKS5jYXRjaChlcnIgPT5cbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHJlcGxlbmlzaCBwb29sIGZvciAke3R5cGV9OmAsIGVycilcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBhZ2VudDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZSBhZ2VudCBiYWNrIHRvIHBvb2xcbiAgICovXG4gIGFzeW5jIHJlbGVhc2VBZ2VudChhZ2VudDogQmFzZUFnZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgdHlwZSA9IGFnZW50LmlkO1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLndhcm1BZ2VudHMuZ2V0KHR5cGUpIHx8IFtdO1xuXG4gICAgLy8gT25seSByZXR1cm4gdG8gcG9vbCBpZiBiZWxvdyBtYXggc2l6ZVxuICAgIGlmIChwb29sLmxlbmd0aCA8IHRoaXMuY29uZmlnLm1heFBvb2xTaXplKSB7XG4gICAgICAvLyBDbGVhbiB1cCBhZ2VudCBzdGF0ZSBiZWZvcmUgcmV0dXJuaW5nIHRvIHBvb2xcbiAgICAgIGF3YWl0IHRoaXMuY2xlYW51cEFnZW50KGFnZW50KTtcblxuICAgICAgcG9vbC5wdXNoKGFnZW50KTtcbiAgICAgIHRoaXMud2FybUFnZW50cy5zZXQodHlwZSwgcG9vbCk7XG4gICAgICB0aGlzLnN0YXRpc3RpY3MuY3VycmVudFBvb2xTaXplcy5zZXQodHlwZSwgcG9vbC5sZW5ndGgpO1xuXG4gICAgICB0aGlzLmVtaXQoJ2FnZW50OnJlbGVhc2VkJywge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwb29sU2l6ZTogcG9vbC5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQb29sIGlzIGZ1bGwsIGRpc2NhcmQgYWdlbnRcbiAgICAgIHRoaXMuZW1pdCgnYWdlbnQ6ZGlzY2FyZGVkJywge1xuICAgICAgICB0eXBlLFxuICAgICAgICByZWFzb246ICdwb29sX2Z1bGwnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIG5ldyBhZ2VudCBpbnN0YW5jZSAod2l0aCBlcnJvciBoYW5kbGluZylcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlQWdlbnQodHlwZTogc3RyaW5nKTogUHJvbWlzZTxCYXNlQWdlbnQ+IHtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ21hcmlhLXFhJzpcbiAgICAgICAgICByZXR1cm4gbmV3IEVuaGFuY2VkTWFyaWEodGhpcy52ZWN0b3JTdG9yZSk7XG4gICAgICAgIGNhc2UgJ2phbWVzLWZyb250ZW5kJzpcbiAgICAgICAgICByZXR1cm4gbmV3IEVuaGFuY2VkSmFtZXModGhpcy52ZWN0b3JTdG9yZSk7XG4gICAgICAgIGNhc2UgJ21hcmN1cy1iYWNrZW5kJzpcbiAgICAgICAgICByZXR1cm4gbmV3IEVuaGFuY2VkTWFyY3VzKHRoaXMudmVjdG9yU3RvcmUpO1xuICAgICAgICBjYXNlICdzYXJhaC1wbSc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTYXJhaFBtKHRoaXMudmVjdG9yU3RvcmUpO1xuICAgICAgICBjYXNlICdhbGV4LWJhJzpcbiAgICAgICAgICByZXR1cm4gbmV3IEFsZXhCYSh0aGlzLnZlY3RvclN0b3JlKTtcbiAgICAgICAgY2FzZSAnZHItYWktbWwnOlxuICAgICAgICAgIHJldHVybiBuZXcgRHJBaU1sKHRoaXMudmVjdG9yU3RvcmUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhZ2VudCB0eXBlOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBjcmVhdGUgYWdlbnQgJHt0eXBlfTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yOyAvLyBSZS10aHJvdyBmb3IgY2FsbGVyIHRvIGhhbmRsZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJtIHVwIGFnZW50IChwcmUtbG9hZCByZXNvdXJjZXMsIFJBRyBwYXR0ZXJucywgZXRjLilcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgd2FybVVwQWdlbnQoYWdlbnQ6IEJhc2VBZ2VudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFdhcm0tdXAgYWN0aXZpdGllczpcbiAgICAvLyAxLiBQcmUtbG9hZCBSQUcgcGF0dGVybnMgKGlmIGFnZW50IHVzZXMgUkFHKVxuICAgIC8vIDIuIEluaXRpYWxpemUgYW55IGhlYXZ5IHJlc291cmNlc1xuICAgIC8vIDMuIENvbXBpbGUgcGF0dGVybnMvcnVsZXNcbiAgICAvLyA0LiBDb25uZWN0IHRvIGV4dGVybmFsIHNlcnZpY2VzIGlmIG5lZWRlZFxuXG4gICAgLy8gRm9yIG5vdywganVzdCBlbnN1cmUgYWdlbnQgaXMgcmVhZHlcbiAgICAvLyBUT0RPOiBBZGQgYWdlbnQtc3BlY2lmaWMgd2FybS11cCBtZXRob2RzIGluIEJhc2VBZ2VudFxuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFnZW50IGJlZm9yZSByZXR1cm5pbmcgdG8gcG9vbFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjbGVhbnVwQWdlbnQoYWdlbnQ6IEJhc2VBZ2VudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIENsZWFudXAgYWN0aXZpdGllczpcbiAgICAvLyAxLiBDbGVhciB0ZW1wb3Jhcnkgc3RhdGVcbiAgICAvLyAyLiBSZXNldCBjb250ZXh0XG4gICAgLy8gMy4gQ2xvc2UgYW55IG9wZW4gY29ubmVjdGlvbnNcbiAgICAvLyA0LiBDbGVhciBjYWNoZXNcblxuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxlbmlzaCBwb29sIHRvIHRhcmdldCBzaXplXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlcGxlbmlzaFBvb2wodHlwZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcG9vbCA9IHRoaXMud2FybUFnZW50cy5nZXQodHlwZSkgfHwgW107XG4gICAgY29uc3QgdGFyZ2V0U2l6ZSA9IHRoaXMuY29uZmlnLmVuYWJsZUFkYXB0aXZlXG4gICAgICA/IHRoaXMuY2FsY3VsYXRlQWRhcHRpdmVTaXplKHR5cGUpXG4gICAgICA6IHRoaXMuY29uZmlnLnBvb2xTaXplO1xuXG4gICAgd2hpbGUgKHBvb2wubGVuZ3RoIDwgdGFyZ2V0U2l6ZSAmJiBwb29sLmxlbmd0aCA8IHRoaXMuY29uZmlnLm1heFBvb2xTaXplKSB7XG4gICAgICBjb25zdCBhZ2VudCA9IGF3YWl0IHRoaXMuY3JlYXRlQWdlbnQodHlwZSk7XG4gICAgICBhd2FpdCB0aGlzLndhcm1VcEFnZW50KGFnZW50KTtcbiAgICAgIHBvb2wucHVzaChhZ2VudCk7XG4gICAgfVxuXG4gICAgdGhpcy53YXJtQWdlbnRzLnNldCh0eXBlLCBwb29sKTtcbiAgICB0aGlzLnN0YXRpc3RpY3MuY3VycmVudFBvb2xTaXplcy5zZXQodHlwZSwgcG9vbC5sZW5ndGgpO1xuXG4gICAgdGhpcy5lbWl0KCdwb29sOnJlcGxlbmlzaGVkJywge1xuICAgICAgdHlwZSxcbiAgICAgIG5ld1NpemU6IHBvb2wubGVuZ3RoXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGFkYXB0aXZlIHBvb2wgc2l6ZSBiYXNlZCBvbiB1c2FnZSBwYXR0ZXJuc1xuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVBZGFwdGl2ZVNpemUodHlwZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAvLyBTaW1wbGUgYWRhcHRpdmUgYWxnb3JpdGhtOlxuICAgIC8vIC0gSWYgaGl0IHJhdGUgPiA5MCU6IGluY3JlYXNlIHBvb2wgc2l6ZVxuICAgIC8vIC0gSWYgaGl0IHJhdGUgPCA1MCU6IGRlY3JlYXNlIHBvb2wgc2l6ZVxuICAgIC8vIC0gT3RoZXJ3aXNlOiBtYWludGFpbiBjdXJyZW50IHNpemVcblxuICAgIHRoaXMudXBkYXRlSGl0UmF0ZSgpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGlzdGljcy5oaXRSYXRlID4gMC45KSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5jb25maWcucG9vbFNpemUgKyAxLCB0aGlzLmNvbmZpZy5tYXhQb29sU2l6ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRpc3RpY3MuaGl0UmF0ZSA8IDAuNSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuY29uZmlnLnBvb2xTaXplIC0gMSwgdGhpcy5jb25maWcubWluUG9vbFNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcucG9vbFNpemU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCBhbGxvY2F0aW9uIHRpbWUgZm9yIHN0YXRpc3RpY3NcbiAgICovXG4gIHByaXZhdGUgcmVjb3JkQWxsb2NhdGlvblRpbWUodGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5hbGxvY2F0aW9uVGltZXMucHVzaCh0aW1lKTtcblxuICAgIC8vIEtlZXAgb25seSBsYXN0IDEwMCBhbGxvY2F0aW9uc1xuICAgIGlmICh0aGlzLmFsbG9jYXRpb25UaW1lcy5sZW5ndGggPiAxMDApIHtcbiAgICAgIHRoaXMuYWxsb2NhdGlvblRpbWVzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGF2ZXJhZ2VcbiAgICBjb25zdCBzdW0gPSB0aGlzLmFsbG9jYXRpb25UaW1lcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICB0aGlzLnN0YXRpc3RpY3MuYXZlcmFnZUFsbG9jYXRpb25UaW1lID0gc3VtIC8gdGhpcy5hbGxvY2F0aW9uVGltZXMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBoaXQgcmF0ZSBzdGF0aXN0aWNcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlSGl0UmF0ZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdGF0aXN0aWNzLnRvdGFsUmVxdWVzdHMgPiAwKSB7XG4gICAgICB0aGlzLnN0YXRpc3RpY3MuaGl0UmF0ZSA9IHRoaXMuc3RhdGlzdGljcy5wb29sSGl0cyAvIHRoaXMuc3RhdGlzdGljcy50b3RhbFJlcXVlc3RzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcG9vbCBzdGF0aXN0aWNzXG4gICAqL1xuICBnZXRTdGF0aXN0aWNzKCk6IFBvb2xTdGF0aXN0aWNzIHtcbiAgICB0aGlzLnVwZGF0ZUhpdFJhdGUoKTtcbiAgICByZXR1cm4geyAuLi50aGlzLnN0YXRpc3RpY3MgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBwb29sIHNpemUgZm9yIGFnZW50IHR5cGVcbiAgICovXG4gIGdldFBvb2xTaXplKHR5cGU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3QgcG9vbCA9IHRoaXMud2FybUFnZW50cy5nZXQodHlwZSkgfHwgW107XG4gICAgcmV0dXJuIHBvb2wubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBwb29scyAod2l0aCBwcm9wZXIgY2xlYW51cCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcylcbiAgICovXG4gIGFzeW5jIGNsZWFyQWxsKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIERlc3Ryb3kgYWdlbnRzIGJlZm9yZSBjbGVhcmluZyBwb29sc1xuICAgIGZvciAoY29uc3QgW3R5cGUsIHBvb2xdIG9mIHRoaXMud2FybUFnZW50cy5lbnRyaWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgYWdlbnQgb2YgcG9vbCkge1xuICAgICAgICBpZiAodHlwZW9mIChhZ2VudCBhcyBhbnkpLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAoYWdlbnQgYXMgYW55KS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLndhcm1BZ2VudHMuY2xlYXIoKTtcbiAgICB0aGlzLnN0YXRpc3RpY3MgPSB7XG4gICAgICB0b3RhbFJlcXVlc3RzOiAwLFxuICAgICAgcG9vbEhpdHM6IDAsXG4gICAgICBwb29sTWlzc2VzOiAwLFxuICAgICAgaGl0UmF0ZTogMCxcbiAgICAgIGF2ZXJhZ2VBbGxvY2F0aW9uVGltZTogMCxcbiAgICAgIGN1cnJlbnRQb29sU2l6ZXM6IG5ldyBNYXAoKVxuICAgIH07XG4gICAgdGhpcy5hbGxvY2F0aW9uVGltZXMgPSBbXTtcblxuICAgIHRoaXMuZW1pdCgncG9vbDpjbGVhcmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBvb2wgc3RhdGlzdGljc1xuICAgKi9cbiAgZ2V0U3RhdHMoKTogYW55IHtcbiAgICBjb25zdCBwb29sU2l6ZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIGNvbnN0IGhpdHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICBjb25zdCBtaXNzZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcblxuICAgIHRoaXMud2FybUFnZW50cy5mb3JFYWNoKChhZ2VudHMsIGFnZW50VHlwZSkgPT4ge1xuICAgICAgcG9vbFNpemVbYWdlbnRUeXBlXSA9IGFnZW50cy5sZW5ndGg7XG4gICAgICBoaXRzW2FnZW50VHlwZV0gPSAwOyAvLyBQbGFjZWhvbGRlciAtIHdvdWxkIHRyYWNrIGluIHJlYWwgaW1wbGVtZW50YXRpb25cbiAgICAgIG1pc3Nlc1thZ2VudFR5cGVdID0gMDtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBwb29sU2l6ZSxcbiAgICAgIGhpdHMsXG4gICAgICBtaXNzZXMsXG4gICAgICB0b3RhbEhpdHM6IHRoaXMuc3RhdGlzdGljcy5wb29sSGl0cyxcbiAgICAgIHRvdGFsTWlzc2VzOiB0aGlzLnN0YXRpc3RpY3MucG9vbE1pc3NlcyxcbiAgICAgIGhpdFJhdGU6IHRoaXMuc3RhdGlzdGljcy5oaXRSYXRlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaHV0ZG93biBhZ2VudCBwb29sXG4gICAqL1xuICBhc3luYyBzaHV0ZG93bigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmNsZWFyQWxsKCk7XG4gICAgdGhpcy5lbWl0KCdwb29sOnNodXRkb3duJyk7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGdsb2JhbEFnZW50UG9vbCA9IG5ldyBBZ2VudFBvb2woKTtcbiJdLCJ2ZXJzaW9uIjozfQ==